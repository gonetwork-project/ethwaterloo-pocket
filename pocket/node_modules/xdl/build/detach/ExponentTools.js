// Copyright 2015-present 650 Industries. All rights reserved.

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createBlankIOSPropertyListAsync = exports.configureIOSLaunchAssetsAsync = exports.configureIOSIconsAsync = exports.cleanIOSPropertyListBackupAsync = exports.modifyIOSPropertyListAsync = exports.transformFileContentsAsync = exports.spawnAsync = exports.spawnAsyncThrowError = exports.getImageDimensionsAsync = exports.getManifestAsync = exports.saveImageToPathAsync = exports.saveUrlToPathAsync = exports.parseSdkMajorVersion = undefined;

let getManifestAsync = (() => {
  var _ref = _asyncToGenerator(function* (url, headers) {
    let requestOptions = {
      url: url.replace('exp://', 'http://') + '/index.exp',
      headers
    };

    let response = yield (_request || _load_request()).default.promise(requestOptions);
    let responseBody = response.body;
    console.log('Using manifest:', responseBody);
    let manifest;
    try {
      manifest = JSON.parse(responseBody);
    } catch (e) {
      throw new Error(`Unable to parse manifest: ${e}`);
    }

    return manifest;
  });

  return function getManifestAsync(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

let spawnAsyncThrowError = (() => {
  var _ref2 = _asyncToGenerator(function* (...args) {
    if (args.length === 2) {
      return (0, (_spawnAsync || _load_spawnAsync()).default)(args[0], args[1], {
        stdio: 'inherit',
        cwd: process.cwd()
      });
    } else {
      return (0, (_spawnAsync || _load_spawnAsync()).default)(...args);
    }
  });

  return function spawnAsyncThrowError() {
    return _ref2.apply(this, arguments);
  };
})();

let spawnAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (...args) {
    try {
      return yield spawnAsyncThrowError(...args);
    } catch (e) {
      console.error(e.message);
    }
  });

  return function spawnAsync() {
    return _ref3.apply(this, arguments);
  };
})();

let transformFileContentsAsync = (() => {
  var _ref4 = _asyncToGenerator(function* (filename, transform) {
    let fileString = yield _fs.default.promise.readFile(filename, 'utf8');
    let newFileString = transform(fileString);
    if (newFileString !== null) {
      yield _fs.default.promise.writeFile(filename, newFileString);
    }
    return;
  });

  return function transformFileContentsAsync(_x3, _x4) {
    return _ref4.apply(this, arguments);
  };
})();

let createBlankIOSPropertyListAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (plistPath, plistName) {
    // write empty json file
    const emptyConfig = {};
    const tmpConfigFile = _path.default.join(plistPath, `${plistName}.json`);
    yield _fs.default.promise.writeFile(tmpConfigFile, JSON.stringify(emptyConfig));

    // convert to plist
    let plistFilename = getNormalizedPlistFilename(plistName);
    let configPlistName = _path.default.join(plistPath, plistFilename);
    yield spawnAsyncThrowError('plutil', ['-convert', 'xml1', tmpConfigFile, '-o', configPlistName]);

    // remove tmp json file
    yield spawnAsyncThrowError('/bin/rm', [tmpConfigFile]);
    return;
  });

  return function createBlankIOSPropertyListAsync(_x5, _x6) {
    return _ref5.apply(this, arguments);
  };
})();

/**
 *  @param plistName base filename of property list. if no extension, assumes .plist
 */


let modifyIOSPropertyListAsync = (() => {
  var _ref6 = _asyncToGenerator(function* (plistPath, plistName, transform) {
    let plistFilename = getNormalizedPlistFilename(plistName);
    let configPlistName = _path.default.join(plistPath, plistFilename);
    let configFilename = _path.default.join(plistPath, `${plistName}.json`);

    // grab original plist as json object
    yield spawnAsyncThrowError('plutil', ['-convert', 'json', configPlistName, '-o', configFilename]);
    let configContents = yield _fs.default.promise.readFile(configFilename, 'utf8');
    let config;

    try {
      config = JSON.parse(configContents);
    } catch (e) {
      console.log(`Error parsing ${configFilename}`, e);
      console.log('The erroneous file contents was:', configContents);
      config = {};
    }

    // apply transformation
    config = transform(config);

    // back up old plist and swap in modified one
    yield spawnAsyncThrowError('/bin/cp', [configPlistName, `${configPlistName}.bak`]);
    yield _fs.default.promise.writeFile(configFilename, JSON.stringify(config));
    yield spawnAsyncThrowError('plutil', ['-convert', 'xml1', configFilename, '-o', configPlistName]);
    return config;
  });

  return function modifyIOSPropertyListAsync(_x7, _x8, _x9) {
    return _ref6.apply(this, arguments);
  };
})();

let cleanIOSPropertyListBackupAsync = (() => {
  var _ref7 = _asyncToGenerator(function* (plistPath, plistName, restoreOriginal = true) {
    let plistFilename = getNormalizedPlistFilename(plistName);
    let configPlistName = _path.default.join(plistPath, plistFilename);
    let configFilename = _path.default.join(plistPath, `${plistName}.json`);

    if (restoreOriginal) {
      yield spawnAsyncThrowError('/bin/cp', [`${configPlistName}.bak`, configPlistName]);
    }

    yield spawnAsyncThrowError('/bin/rm', [`${configPlistName}.bak`]);
    yield spawnAsyncThrowError('/bin/rm', [configFilename]);
    return;
  });

  return function cleanIOSPropertyListBackupAsync(_x10, _x11) {
    return _ref7.apply(this, arguments);
  };
})();

/**
 *  @return array [ width, height ] or nil if that fails for some reason.
 */
let getImageDimensionsAsync = (() => {
  var _ref8 = _asyncToGenerator(function* (dirname, basename) {
    if (process.platform !== 'darwin') {
      console.warn('`sips` utility may or may not work outside of macOS');
    }
    let childProcess = yield spawnAsyncThrowError('sips', ['-g', 'pixelWidth', '-g', 'pixelHeight', basename], {
      cwd: dirname
    });
    let dimensions;
    try {
      // stdout looks something like 'pixelWidth: 1200\n pixelHeight: 800'
      const components = childProcess.stdout.split(/(\s+)/);
      dimensions = components.map(function (c) {
        return parseInt(c, 10);
      }).filter(function (n) {
        return !isNaN(n);
      });
    } catch (_) {}
    return dimensions;
  });

  return function getImageDimensionsAsync(_x12, _x13) {
    return _ref8.apply(this, arguments);
  };
})();

let configureIOSLaunchAssetsAsync = (() => {
  var _ref9 = _asyncToGenerator(function* (manifest, projectRoot, srcRoot) {
    if (!(manifest.splash || manifest.ios && manifest.ios.splash || manifest.android && manifest.android.splash)) {
      // Don't do loading xib customizations if `splash` keys don't exist
      return;
    }

    console.log('Configuring iOS Launch Screen');
    let splashXibFilename = _path.default.join(srcRoot, 'Exponent', 'Base.lproj', 'LaunchScreenShell.xib');
    let splashOutputFilename = _path.default.join(projectRoot, 'Base.lproj', 'LaunchScreenShell.nib');

    yield transformFileContentsAsync(splashXibFilename, function (fileString) {
      var parser = new (_xmldom || _load_xmldom()).DOMParser();
      var serializer = new (_xmldom || _load_xmldom()).XMLSerializer();
      var dom = parser.parseFromString(fileString);

      setBackgroundColor(manifest, dom);
      setBackgroundImageResizeMode(manifest, dom);

      var fileString = serializer.serializeToString(dom);
      return fileString;
    });

    yield setBackgroundImage(manifest, projectRoot);

    yield spawnAsyncThrowError('ibtool', ['--compile', splashOutputFilename, splashXibFilename]);

    console.log('DONE Configuring iOS Launch Screen');
  });

  return function configureIOSLaunchAssetsAsync(_x14, _x15, _x16) {
    return _ref9.apply(this, arguments);
  };
})();

let setBackgroundImage = (() => {
  var _ref10 = _asyncToGenerator(function* (manifest, projectRoot) {
    let tabletImage;
    let phoneImage;

    if (manifest.ios && manifest.ios.splash && manifest.ios.splash.imageUrl) {
      phoneImage = manifest.ios.splash.imageUrl;

      if (manifest.ios.splash.tabletImageUrl) {
        tabletImage = manifest.ios.splash.tabletImageUrl;
      }
    } else if (manifest.splash && manifest.splash.imageUrl) {
      phoneImage = manifest.splash.imageUrl;
    }

    if (!phoneImage) {
      return;
    }

    var outputs = [];
    if (!tabletImage) {
      outputs.push({
        url: phoneImage,
        path: _path.default.join(projectRoot, 'launch_background_image.png')
      });
    } else {
      outputs.push({
        url: phoneImage,
        path: _path.default.join(projectRoot, 'launch_background_image~iphone.png')
      });
      outputs.push({
        url: tabletImage,
        path: _path.default.join(projectRoot, 'launch_background_image.png')
      });
    }

    outputs.forEach((() => {
      var _ref11 = _asyncToGenerator(function* (output) {
        let { url, path } = output;
        console.log(url, path, output);
        yield saveImageToPathAsync(projectRoot, url, path);
      });

      return function (_x19) {
        return _ref11.apply(this, arguments);
      };
    })());
  });

  return function setBackgroundImage(_x17, _x18) {
    return _ref10.apply(this, arguments);
  };
})();

/**
 * Based on keys in the given manifest,
 * ensure that the proper iOS icon images exist -- assuming Info.plist already
 * points at them under CFBundleIcons.CFBundlePrimaryIcon.CFBundleIconFiles.
 *
 * This only works on MacOS (as far as I know) because it uses the sips utility.
 */
let configureIOSIconsAsync = (() => {
  var _ref12 = _asyncToGenerator(function* (manifest, destinationIconPath, projectRoot) {
    if (process.platform !== 'darwin') {
      console.warn('`sips` utility may or may not work outside of macOS');
    }
    let defaultIconFilename;
    if (manifest.ios && manifest.ios.iconUrl) {
      defaultIconFilename = 'exp-icon.png';
      yield saveUrlToPathAsync(manifest.ios.iconUrl, `${destinationIconPath}/${defaultIconFilename}`);
    } else if (manifest.iconUrl) {
      defaultIconFilename = 'exp-icon.png';
      yield saveUrlToPathAsync(manifest.iconUrl, `${destinationIconPath}/${defaultIconFilename}`);
    } else if (projectRoot && manifest.icon) {
      defaultIconFilename = 'exp-icon.png';
      yield saveImageToPathAsync(projectRoot, manifest.icon, `${destinationIconPath}/${defaultIconFilename}`);
    }

    let iconSizes = [20, 29, 40, 60, 76, 83.5, 1024];
    iconSizes.forEach(function (iconSize) {
      let iconResolutions;
      if (iconSize === 76) {
        // iPad has 1x and 2x icons for this size only
        iconResolutions = [1, 2];
      } else if (iconSize == 1024) {
        // marketing icon is weird
        iconResolutions = [1];
      } else {
        iconResolutions = [2, 3];
      }
      iconResolutions.forEach((() => {
        var _ref13 = _asyncToGenerator(function* (iconResolution) {
          let iconQualifier = getAppleIconQualifier(iconSize, iconResolution);
          // TODO(nikki): Support local paths for these icons
          let iconKey = `iconUrl${iconQualifier}`;
          let rawIconFilename;
          let usesDefault = false;
          if (manifest.ios && manifest.ios.hasOwnProperty(iconKey)) {
            // manifest specifies an image just for this size/resolution, use that
            rawIconFilename = `exp-icon${iconQualifier}.png`;
            yield saveUrlToPathAsync(manifest.ios[iconKey], `${destinationIconPath}/${rawIconFilename}`);
          } else {
            // use default manifest.iconUrl
            usesDefault = true;
            if (defaultIconFilename) {
              rawIconFilename = defaultIconFilename;
            } else {
              console.warn(`Manifest does not specify ios.${iconKey} nor a default iconUrl. Bundle will use the Expo logo.`);
              return;
            }
          }

          let iconFilename = `AppIcon${iconQualifier}.png`;
          let iconSizePx = iconSize * iconResolution;
          yield spawnAsyncThrowError('/bin/cp', [rawIconFilename, iconFilename], {
            stdio: 'inherit',
            cwd: destinationIconPath
          });
          yield spawnAsyncThrowError('sips', ['-Z', iconSizePx, iconFilename], {
            stdio: ['ignore', 'ignore', 'inherit'], // only stderr
            cwd: destinationIconPath
          });

          // reject non-square icons (because Apple will if we don't)
          const dims = yield getImageDimensionsAsync(destinationIconPath, iconFilename);
          if (!dims || dims.length < 2 || dims[0] !== dims[1]) {
            throw new Error(`iOS icons must be square, the dimensions of ${iconFilename} are ${dims}`);
          }

          if (!usesDefault) {
            // non-default icon used, clean up the downloaded version
            yield spawnAsyncThrowError('/bin/rm', [_path.default.join(destinationIconPath, rawIconFilename)]);
          }
        });

        return function (_x23) {
          return _ref13.apply(this, arguments);
        };
      })());
    });

    // clean up default icon
    if (defaultIconFilename) {
      yield spawnAsyncThrowError('/bin/rm', [_path.default.join(destinationIconPath, defaultIconFilename)]);
    }
    return;
  });

  return function configureIOSIconsAsync(_x20, _x21, _x22) {
    return _ref12.apply(this, arguments);
  };
})();

var _fs = _interopRequireDefault(require('fs'));

require('instapromise');

var _path = _interopRequireDefault(require('path'));

var _request;

function _load_request() {
  return _request = _interopRequireDefault(require('request'));
}

var _spawnAsync;

function _load_spawnAsync() {
  return _spawnAsync = _interopRequireDefault(require('@expo/spawn-async'));
}

var _xmldom;

function _load_xmldom() {
  return _xmldom = require('xmldom');
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const ASPECT_FILL = 'scaleAspectFill';
const ASPECT_FIT = 'scaleAspectFit';

const backgroundImageViewID = 'Bsh-cT-K4l';
const backgroundViewID = 'OfY-5Y-tS4';

function parseSdkMajorVersion(expSdkVersion) {
  let sdkMajorVersion = 0;
  try {
    let versionComponents = expSdkVersion.split('.').map(number => parseInt(number, 10));
    sdkMajorVersion = versionComponents[0];
  } catch (_) {}
  return sdkMajorVersion;
}

function saveUrlToPathAsync(url, path) {
  return new Promise(function (resolve, reject) {
    let stream = _fs.default.createWriteStream(path);
    stream.on('close', () => {
      if (getFilesizeInBytes(path) < 10) {
        throw new Error(`{filename} is too small`);
      }
      resolve();
    });
    stream.on('error', reject);
    (0, (_request || _load_request()).default)(url).pipe(stream);
  });
}

function saveImageToPathAsync(projectRoot, pathOrURL, outPath) {
  const localPath = _path.default.resolve(projectRoot, pathOrURL);
  return new Promise(function (resolve, reject) {
    let stream = _fs.default.createWriteStream(outPath);
    stream.on('close', () => {
      if (getFilesizeInBytes(outPath) < 10) {
        throw new Error(`{filename} is too small`);
      }
      resolve();
    });
    stream.on('error', reject);
    if (_fs.default.existsSync(localPath)) {
      _fs.default.createReadStream(localPath).pipe(stream);
    } else {
      (0, (_request || _load_request()).default)(pathOrURL).pipe(stream);
    }
  });
}

function getFilesizeInBytes(path) {
  let stats = _fs.default.statSync(path);
  let fileSizeInBytes = stats['size'];
  return fileSizeInBytes;
}

function getNormalizedPlistFilename(plistName) {
  let plistFilename;
  if (plistName.indexOf('.') !== -1) {
    plistFilename = plistName;
  } else {
    plistFilename = `${plistName}.plist`;
  }
  return plistFilename;
}

function getAppleIconQualifier(iconSize, iconResolution) {
  let iconQualifier;
  if (iconResolution !== 1) {
    // e.g. "29x29@3x"
    iconQualifier = `${iconSize}x${iconSize}@${iconResolution}x`;
  } else {
    iconQualifier = `${iconSize}x${iconSize}`;
  }
  if (iconSize === 76 || iconSize === 83.5) {
    // ipad sizes require ~ipad at the end
    iconQualifier = `${iconQualifier}~ipad`;
  }
  return iconQualifier;
}

function backgroundColorFromHexString(hexColor) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexColor);
  if (result.length < 4) {
    // Default to white if we can't parse the color. We should have 3 matches.
    console.warn('Unable to parse color: ', hexColor, ' result:', result);
    return { r: 1, g: 1, b: 1 };
  }

  var r = parseInt(result[1], 16) / 255;
  var g = parseInt(result[2], 16) / 255;
  var b = parseInt(result[3], 16) / 255;
  return { r, g, b };
}

function setBackgroundImageResizeMode(manifest, dom) {
  let backgroundViewMode = (() => {
    let mode;
    if (!manifest) {
      return ASPECT_FIT;
    }

    if (manifest.ios && manifest.ios.splash && manifest.ios.splash.resizeMode) {
      mode = manifest.ios.splash.resizeMode;
    } else if (manifest.splash.resizeMode) {
      mode = manifest.splash.resizeMode;
    }

    return mode === 'cover' ? ASPECT_FILL : ASPECT_FIT;
  })();

  var backgroundImageViewNode = dom.getElementById(backgroundImageViewID);
  if (backgroundImageViewNode) {
    backgroundImageViewNode.setAttribute('contentMode', backgroundViewMode);
  }
}

function setBackgroundColor(manifest, dom) {
  var backgroundColorString;
  if (manifest.ios && manifest.ios.splash && manifest.ios.splash.backgroundColor) {
    backgroundColorString = manifest.ios.splash.backgroundColor;
  } else if (manifest.splash && manifest.splash.backgroundColor) {
    backgroundColorString = manifest.splash.backgroundColor;
  }

  // Fallback to old version
  if (!backgroundColorString) {
    backgroundColorString = manifest.loading.backgroundColor;
  }

  // Default to white
  if (!backgroundColorString) {
    backgroundColorString = '#FFFFFF';
  }

  const { r, g, b } = backgroundColorFromHexString(backgroundColorString);
  var backgroundViewNode = dom.getElementById(backgroundViewID);
  var backgroundViewColorNodes = backgroundViewNode.getElementsByTagName('color');
  var backgroundColorNode;
  for (var i = 0; i < backgroundViewColorNodes.length; i++) {
    var node = backgroundViewColorNodes[i];
    if (node.parentNode.getAttribute('id') !== backgroundViewID) {
      continue;
    }

    if (node.getAttribute('key') === 'backgroundColor') {
      backgroundColorNode = node;
      break;
    }
  }

  if (backgroundColorNode) {
    backgroundColorNode.setAttribute('red', r);
    backgroundColorNode.setAttribute('green', g);
    backgroundColorNode.setAttribute('blue', b);
  }
}exports.parseSdkMajorVersion = parseSdkMajorVersion;
exports.saveUrlToPathAsync = saveUrlToPathAsync;
exports.saveImageToPathAsync = saveImageToPathAsync;
exports.getManifestAsync = getManifestAsync;
exports.getImageDimensionsAsync = getImageDimensionsAsync;
exports.spawnAsyncThrowError = spawnAsyncThrowError;
exports.spawnAsync = spawnAsync;
exports.transformFileContentsAsync = transformFileContentsAsync;
exports.modifyIOSPropertyListAsync = modifyIOSPropertyListAsync;
exports.cleanIOSPropertyListBackupAsync = cleanIOSPropertyListBackupAsync;
exports.configureIOSIconsAsync = configureIOSIconsAsync;
exports.configureIOSLaunchAssetsAsync = configureIOSLaunchAssetsAsync;
exports.createBlankIOSPropertyListAsync = createBlankIOSPropertyListAsync;
//# sourceMappingURL=../__sourcemaps__/detach/ExponentTools.js.map
